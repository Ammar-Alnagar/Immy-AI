[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "sys",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "sys",
        "description": "sys",
        "detail": "sys",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "queue",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "queue",
        "description": "queue",
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "Queue",
        "importPath": "queue",
        "description": "queue",
        "isExtraImport": true,
        "detail": "queue",
        "documentation": {}
    },
    {
        "label": "threading",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "threading",
        "description": "threading",
        "detail": "threading",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Iterator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "Groq",
        "importPath": "groq",
        "description": "groq",
        "isExtraImport": true,
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "Groq",
        "importPath": "groq",
        "description": "groq",
        "isExtraImport": true,
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "pydub.playback",
        "description": "pydub.playback",
        "isExtraImport": true,
        "detail": "pydub.playback",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "pyaudio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyaudio",
        "description": "pyaudio",
        "detail": "pyaudio",
        "documentation": {}
    },
    {
        "label": "numpy",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "numpy",
        "description": "numpy",
        "detail": "numpy",
        "documentation": {}
    },
    {
        "label": "WhisperModel",
        "importPath": "faster_whisper",
        "description": "faster_whisper",
        "isExtraImport": true,
        "detail": "faster_whisper",
        "documentation": {}
    },
    {
        "label": "RPi.GPIO",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "RPi.GPIO",
        "description": "RPi.GPIO",
        "detail": "RPi.GPIO",
        "documentation": {}
    },
    {
        "label": "AudioStreamPlayer",
        "kind": 6,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "class AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()\n    def add_audio_chunk(self, chunk):\n        if chunk:\n            self.audio_queue.put(chunk)\n    def play_audio_stream(self):",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "ConversationApp",
        "kind": 6,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "class ConversationApp:\n    def __init__(self):\n        self.window = tk.Tk()\n        self.window.title(\"Interactive Conversation System\")\n        self.text_queue = queue.Queue()\n        self.audio_player = AudioStreamPlayer()\n        # Start audio player thread\n        self.audio_thread = threading.Thread(\n            target=self.audio_player.play_audio_stream,\n            daemon=True",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "stream_to_eleven_labs",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def stream_to_eleven_labs(text_queue: queue.Queue, audio_player: AudioStreamPlayer):\n    accumulated_text = \"\"\n    while True:\n        while not text_queue.empty():\n            text_chunk = text_queue.get()\n            accumulated_text += text_chunk\n            # Process text when we have enough for natural speech\n            if len(accumulated_text.strip()) > 0 and (accumulated_text.strip()[-1] in '.!?'):\n                try:\n                    audio_stream = eleven_labs_client.text_to_speech.convert_as_stream(",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "send_to_groq_streaming",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def send_to_groq_streaming(user_input: str, text_queue: queue.Queue) -> None:\n    system_prompt = (\n        \"You are Immy, a magical AI-powered teddy bear who loves to chat with children. \"\n        \"You are kind, funny, and full of wonder, always ready to tell stories, answer questions, and offer friendly advice. \"\n        \"When speaking, you are playful, patient, and use simple, child-friendly language. You encourage curiosity, learning, and imagination.\"\n        \"keep your responses short and cute\"\n        \"Dont use emojis in your responses. \"\n    )\n    try:\n        stream = groq_client.chat.completions.create(",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "GROQ_API_KEY",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "GROQ_API_KEY = os.getenv(\"GROQ_API_KEY\")\nELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize clients\ngroq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize clients\ngroq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "groq_client",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "groq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()\n    def add_audio_chunk(self, chunk):\n        if chunk:",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()\n    def add_audio_chunk(self, chunk):\n        if chunk:\n            self.audio_queue.put(chunk)",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(\n            stability=0.0,",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "send_to_LLMinBox",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def send_to_LLMinBox(user_input):\n    payload = {\"question\": user_input}\n    try:\n        response = requests.post(LLMINABOX_API_URL, json=payload)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        print(f\"Response status code: {response.status_code}\")\n        # Try to parse the JSON response\n        json_response = response.json()\n        # Extract the text from the response\n        response_text = json_response.get('text', 'No text field in JSON')",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def main():\n    while True:\n        user_input = recognize_speech()\n        if user_input:\n            response_text = send_to_LLMinBox(user_input)\n            print(\"LLMinaBox response:\", response_text)\n            if not response_text.startswith(\"Error:\"):\n                # Send the response_text directly to ElevenLabs for TTS\n                audio_stream = text_to_speech_stream(response_text)\n                play_audio(audio_stream)",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\nLLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "LLMINABOX_API_URL",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "LLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "SpeechBot",
        "kind": 6,
        "importPath": "offline",
        "description": "offline",
        "peekOfCode": "class SpeechBot:\n    def __init__(self):\n        self.OLLAMA_API_URL = \"http://localhost:11434/api/chat\"\n        # Initialize text-to-speech engine\n        self.engine = pyttsx3.init()\n        self.engine.setProperty('rate', 150)\n        self.engine.setProperty('volume', 0.9)\n        # Initialize Faster Whisper with optimized settings\n        print(\"Loading Whisper model...\")\n        self.model = WhisperModel(",
        "detail": "offline",
        "documentation": {}
    },
    {
        "label": "os.environ[\"KMP_DUPLICATE_LIB_OK\"]",
        "kind": 5,
        "importPath": "offline",
        "description": "offline",
        "peekOfCode": "os.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"\nclass SpeechBot:\n    def __init__(self):\n        self.OLLAMA_API_URL = \"http://localhost:11434/api/chat\"\n        # Initialize text-to-speech engine\n        self.engine = pyttsx3.init()\n        self.engine.setProperty('rate', 150)\n        self.engine.setProperty('volume', 0.9)\n        # Initialize Faster Whisper with optimized settings\n        print(\"Loading Whisper model...\")",
        "detail": "offline",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        optimize_streaming_latency=\"4\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "send_to_LLMinBox",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def send_to_LLMinBox(user_input):\n    payload = {\"question\": user_input}\n    try:\n        response = requests.post(LLMINABOX_API_URL, json=payload , stream=True)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        print(f\"Response status code: {response.status_code}\")\n        # Try to parse the JSON response\n        json_response = response.json()\n        # Extract the text from the response\n        response_text = json_response.get('text', 'No text field in JSON')",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "start_recording",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def start_recording():\n    user_input = recognize_speech()\n    if user_input:\n        response_text = send_to_LLMinBox(user_input)\n        print(\"LLMinaBox response:\", response_text)\n        if not response_text.startswith(\"Error:\"):\n            # Send the response_text directly to ElevenLabs for TTS\n            audio_stream = text_to_speech_stream(response_text)\n            play_audio(audio_stream)\n        else:",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def create_gui():\n    window = tk.Tk()\n    window.title(\"Speech Recognition App\")\n    # Create and place the button on the window\n    record_button = tk.Button(window, text=\"Start Recording\", command=start_recording, padx=20, pady=10)\n    record_button.pack(pady=20)\n    # Start the Tkinter main loop\n    window.mainloop()\nif __name__ == \"__main__\":\n    create_gui()",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\nLLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "LLMINABOX_API_URL",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "LLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        optimize_streaming_latency=\"4\",\n        text=text,",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "AudioStreamPlayer",
        "kind": 6,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "class AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()\n    def add_audio_chunk(self, chunk):\n        if chunk:\n            self.audio_queue.put(chunk)\n    def play_audio_stream(self):",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "stream_to_eleven_labs",
        "kind": 2,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "def stream_to_eleven_labs(text_queue: queue.Queue, audio_player: AudioStreamPlayer):\n    accumulated_text = \"\"\n    while True:\n        while not text_queue.empty():\n            text_chunk = text_queue.get()\n            accumulated_text += text_chunk\n            # Process text when we have enough for natural speech\n            if len(accumulated_text.strip()) > 0 and (accumulated_text.strip()[-1] in '.!?'):\n                try:\n                    audio_stream = eleven_labs_client.text_to_speech.convert_as_stream(",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "send_to_groq_streaming",
        "kind": 2,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "def send_to_groq_streaming(user_input: str, text_queue: queue.Queue) -> None:\n    system_prompt = (\n        \"You are Immy, a magical AI-powered teddy bear who loves to chat with children. \"\n        \"You are kind, funny, and full of wonder, always ready to tell stories, answer questions, and offer friendly advice. \"\n        \"When speaking, you are playful, patient, and use simple, child-friendly language. You encourage curiosity, learning, and imagination.\"\n        \"Keep your responses short and cute.\"\n        \"Don't use emojis in your responses.\"\n    )\n    try:\n        stream = groq_client.chat.completions.create(",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "def main():\n    audio_player = AudioStreamPlayer()\n    text_queue = queue.Queue()\n    # Start audio player thread\n    audio_thread = threading.Thread(target=audio_player.play_audio_stream, daemon=True)\n    audio_thread.start()\n    # Start text-to-speech conversion thread\n    tts_thread = threading.Thread(target=stream_to_eleven_labs, args=(text_queue, audio_player), daemon=True)\n    tts_thread.start()\n    print(\"Waiting for button press...\")",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "GROQ_API_KEY",
        "kind": 5,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "GROQ_API_KEY = os.getenv(\"GROQ_API_KEY\")\nELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize clients\ngroq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\nclass AudioStreamPlayer:",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize clients\ngroq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\nclass AudioStreamPlayer:\n    def __init__(self):",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "groq_client",
        "kind": 5,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "groq_client = Groq(api_key=GROQ_API_KEY)\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "BUTTON_PIN",
        "kind": 5,
        "importPath": "Groq_raseberrypi_ver1",
        "description": "Groq_raseberrypi_ver1",
        "peekOfCode": "BUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\nclass AudioStreamPlayer:\n    def __init__(self):\n        pygame.mixer.init(frequency=22050)\n        self.audio_queue = queue.Queue()\n        self.is_playing = False\n        self.current_buffer = BytesIO()\n    def add_audio_chunk(self, chunk):",
        "detail": "Groq_raseberrypi_ver1",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        optimize_streaming_latency=\"4\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "send_to_LLMinBox",
        "kind": 2,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "def send_to_LLMinBox(user_input):\n    payload = {\"question\": user_input}\n    try:\n        response = requests.post(LLMINABOX_API_URL, json=payload, stream=True)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        print(f\"Response status code: {response.status_code}\")\n        # Try to parse the JSON response\n        json_response = response.json()\n        # Extract the text from the response\n        response_text = json_response.get('text', 'No text field in JSON')",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "def main():\n    print(\"Waiting for button press...\")\n    while True:\n        # Detect button press (falling edge)\n        if GPIO.input(BUTTON_PIN) == GPIO.LOW:\n            user_input = recognize_speech()\n            if user_input:\n                response_text = send_to_LLMinBox(user_input)\n                print(\"LLMinaBox response:\", response_text)\n                if not response_text.startswith(\"Error:\"):",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\nLLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "LLMINABOX_API_URL",
        "kind": 5,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "LLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# GPIO setup for button\nBUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    },
    {
        "label": "BUTTON_PIN",
        "kind": 5,
        "importPath": "LLMinaBox_raspberrypi",
        "description": "LLMinaBox_raspberrypi",
        "peekOfCode": "BUTTON_PIN = 17\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(BUTTON_PIN, GPIO.IN, pull_up_down=GPIO.PUD_UP)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert_as_stream(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "LLMinaBox_raspberrypi",
        "documentation": {}
    }
]