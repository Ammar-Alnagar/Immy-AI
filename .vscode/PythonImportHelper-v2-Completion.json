[
    {
        "label": "os",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "os",
        "description": "os",
        "detail": "os",
        "documentation": {}
    },
    {
        "label": "time",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "time",
        "description": "time",
        "detail": "time",
        "documentation": {}
    },
    {
        "label": "requests",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "requests",
        "description": "requests",
        "detail": "requests",
        "documentation": {}
    },
    {
        "label": "speech_recognition",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "speech_recognition",
        "description": "speech_recognition",
        "detail": "speech_recognition",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "IO",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "AsyncGenerator",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "Optional",
        "importPath": "typing",
        "description": "typing",
        "isExtraImport": true,
        "detail": "typing",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "BytesIO",
        "importPath": "io",
        "description": "io",
        "isExtraImport": true,
        "detail": "io",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "VoiceSettings",
        "importPath": "elevenlabs",
        "description": "elevenlabs",
        "isExtraImport": true,
        "detail": "elevenlabs",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "ElevenLabs",
        "importPath": "elevenlabs.client",
        "description": "elevenlabs.client",
        "isExtraImport": true,
        "detail": "elevenlabs.client",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "load_dotenv",
        "importPath": "dotenv",
        "description": "dotenv",
        "isExtraImport": true,
        "detail": "dotenv",
        "documentation": {}
    },
    {
        "label": "pygame",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pygame",
        "description": "pygame",
        "detail": "pygame",
        "documentation": {}
    },
    {
        "label": "tkinter",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "tkinter",
        "description": "tkinter",
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "ttk",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "messagebox",
        "importPath": "tkinter",
        "description": "tkinter",
        "isExtraImport": true,
        "detail": "tkinter",
        "documentation": {}
    },
    {
        "label": "Groq",
        "importPath": "groq",
        "description": "groq",
        "isExtraImport": true,
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "Groq",
        "importPath": "groq",
        "description": "groq",
        "isExtraImport": true,
        "detail": "groq",
        "documentation": {}
    },
    {
        "label": "json",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "json",
        "description": "json",
        "detail": "json",
        "documentation": {}
    },
    {
        "label": "AudioSegment",
        "importPath": "pydub",
        "description": "pydub",
        "isExtraImport": true,
        "detail": "pydub",
        "documentation": {}
    },
    {
        "label": "play",
        "importPath": "pydub.playback",
        "description": "pydub.playback",
        "isExtraImport": true,
        "detail": "pydub.playback",
        "documentation": {}
    },
    {
        "label": "pyttsx3",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "pyttsx3",
        "description": "pyttsx3",
        "detail": "pyttsx3",
        "documentation": {}
    },
    {
        "label": "quote",
        "importPath": "urllib.parse",
        "description": "urllib.parse",
        "isExtraImport": true,
        "detail": "urllib.parse",
        "documentation": {}
    },
    {
        "label": "asyncio",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "asyncio",
        "description": "asyncio",
        "detail": "asyncio",
        "documentation": {}
    },
    {
        "label": "websockets",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "websockets",
        "description": "websockets",
        "detail": "websockets",
        "documentation": {}
    },
    {
        "label": "base64",
        "kind": 6,
        "isExtraImport": true,
        "importPath": "base64",
        "description": "base64",
        "detail": "base64",
        "documentation": {}
    },
    {
        "label": "dataclass",
        "importPath": "dataclasses",
        "description": "dataclasses",
        "isExtraImport": true,
        "detail": "dataclasses",
        "documentation": {}
    },
    {
        "label": "asynccontextmanager",
        "importPath": "contextlib",
        "description": "contextlib",
        "isExtraImport": true,
        "detail": "contextlib",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(\n            stability=0.0,",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "send_to_LLMinBox",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def send_to_LLMinBox(user_input):\n    payload = {\"question\": user_input}\n    try:\n        response = requests.post(LLMINABOX_API_URL, json=payload)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        print(f\"Response status code: {response.status_code}\")\n        # Try to parse the JSON response\n        json_response = response.json()\n        # Extract the text from the response\n        response_text = json_response.get('text', 'No text field in JSON')",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "start_recording",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def start_recording():\n    user_input = recognize_speech()\n    if user_input:\n        response_text = send_to_LLMinBox(user_input)\n        print(\"LLMinaBox response:\", response_text)\n        if not response_text.startswith(\"Error:\"):\n            # Send the response_text directly to ElevenLabs for TTS\n            audio_stream = text_to_speech_stream(response_text)\n            play_audio(audio_stream)\n        else:",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "def create_gui():\n    window = tk.Tk()\n    window.title(\"Speech Recognition App\")\n    # Create and place the button on the window\n    record_button = tk.Button(window, text=\"Start Recording\", command=start_recording, padx=20, pady=10)\n    record_button.pack(pady=20)\n    # Start the Tkinter main loop\n    window.mainloop()\nif __name__ == \"__main__\":\n    create_gui()",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\nLLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "LLMINABOX_API_URL",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "LLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "LLMinAbox",
        "description": "LLMinAbox",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",",
        "detail": "LLMinAbox",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(\n            stability=0.0,",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        start_time = time.time()\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            end_time = time.time()\n            print(f\"Recognized: {text}\")",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "send_to_groq",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def send_to_groq(user_input):\n    # Define the system prompt to guide the model's behavior\n    system_prompt = (\n        \"You are Immy, a magical AI-powered teddy bear who loves to chat with children. \"\n        \"You are kind, funny, and full of wonder, always ready to tell stories, answer questions, and offer friendly advice. \"\n        \"When speaking, you are playful, patient, and use simple, child-friendly language. You encourage curiosity, learning, and imagination.\"\n    )\n    start_time = time.time()\n    # Send the prompt and user message to Groq API\n    chat_response = groq_client.chat.completions.create(",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "start_recording",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def start_recording():\n    user_input = recognize_speech()\n    if user_input:\n        response_text = send_to_groq(user_input)\n        print(\"Groq response:\", response_text)\n        if response_text:\n            audio_stream = text_to_speech_stream(response_text)\n            play_audio(audio_stream)\n        else:\n            print(\"No response from Groq.\")",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "def create_gui():\n    window = tk.Tk()\n    window.title(\"Speech Recognition with Groq & Eleven Labs\")\n    # Create and place the button on the window\n    record_button = tk.Button(window, text=\"Start Recording\", command=start_recording, padx=20, pady=10)\n    record_button.pack(pady=20)\n    # Start the Tkinter main loop\n    window.mainloop()\nif __name__ == \"__main__\":\n    create_gui()",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "GROQ_API_KEY",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "GROQ_API_KEY = os.getenv(\"GROQ_API_KEY\")\nELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize Groq client\ngroq_client = Groq(api_key=GROQ_API_KEY)\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize Groq client\ngroq_client = Groq(api_key=GROQ_API_KEY)\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "groq_client",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "groq_client = Groq(api_key=GROQ_API_KEY)\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "Groq",
        "description": "Groq",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",",
        "detail": "Groq",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",\n        voice_settings=VoiceSettings(\n            stability=0.0,",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            print(f\"Recognized: {text}\")\n            return text\n        except Exception as e:",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "send_to_LLMinBox",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def send_to_LLMinBox(user_input):\n    payload = {\"question\": user_input}\n    try:\n        response = requests.post(LLMINABOX_API_URL, json=payload)\n        response.raise_for_status()  # Raise an exception for bad status codes\n        print(f\"Response status code: {response.status_code}\")\n        # Try to parse the JSON response\n        json_response = response.json()\n        # Extract the text from the response\n        response_text = json_response.get('text', 'No text field in JSON')",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def play_audio(audio_stream):\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()\n    # Wait for the audio to finish playing\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "def main():\n    while True:\n        user_input = recognize_speech()\n        if user_input:\n            response_text = send_to_LLMinBox(user_input)\n            print(\"LLMinaBox response:\", response_text)\n            if not response_text.startswith(\"Error:\"):\n                # Send the response_text directly to ElevenLabs for TTS\n                audio_stream = text_to_speech_stream(response_text)\n                play_audio(audio_stream)",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\nLLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "LLMINABOX_API_URL",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "LLMINABOX_API_URL = os.getenv(\"LLMINABOX_API_URL\")\n# Initialize Eleven Labs client\neleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "eleven_labs_client",
        "kind": 5,
        "importPath": "nobutton",
        "description": "nobutton",
        "peekOfCode": "eleven_labs_client = ElevenLabs(api_key=ELEVENLABS_API_KEY)\n# Function to convert text to speech and return as audio stream\ndef text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Perform the text-to-speech conversion\n    response = eleven_labs_client.text_to_speech.convert(\n        voice_id=\"jBpfuIE2acCO8z3wKNLl\",  # Adam pre-made voice\n        output_format=\"mp3_22050_32\",\n        text=text,\n        model_id=\"eleven_turbo_v2_5\",",
        "detail": "nobutton",
        "documentation": {}
    },
    {
        "label": "SpeechBot",
        "kind": 6,
        "importPath": "offline",
        "description": "offline",
        "peekOfCode": "class SpeechBot:\n    def __init__(self):\n        self.OLLAMA_API_URL = \"http://localhost:11434/api/generate\"\n        self.engine = pyttsx3.init()\n        # Default voice settings for a kid-friendly voice\n        self.engine.setProperty('rate', 150)     # Speed of speech\n        self.engine.setProperty('volume', 0.9)   # Volume level\n        # Get available voices\n        self.voices = self.engine.getProperty('voices')\n        self.current_voice_idx = 0",
        "detail": "offline",
        "documentation": {}
    },
    {
        "label": "ChatApp",
        "kind": 6,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "class ChatApp:\n    def __init__(self, root):\n        self.root = root\n        self.root.title(\"AI Teddy Bear Chat\")\n        self.root.geometry(\"400x500\")\n        # Create main frame\n        main_frame = tk.Frame(root, padx=20, pady=20)\n        main_frame.pack(fill=tk.BOTH, expand=True)\n        # Chat history display\n        self.chat_history = tk.Text(main_frame, height=15, width=40, wrap=tk.WORD, state='disabled')",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "text_to_speech_stream",
        "kind": 2,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "def text_to_speech_stream(text: str) -> IO[bytes]:\n    start_time = time.time()\n    # Mimic 3 server URL - adjust if running on different port\n    MIMIC3_URL = \"http://localhost:59125/api/tts\"\n    # Parameters for Mimic 3\n    params = {\n        \"text\": text,\n        \"voice\": \"en_US/vctk_low#p226\",  # You can change the voice\n        \"noiseScale\": 0.667,\n        \"noiseW\": 0.8,",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        start_time = time.time()\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            end_time = time.time()\n            print(f\"Recognized: {text}\")",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "send_to_ollama",
        "kind": 2,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "def send_to_ollama(user_input):\n    # Define the system prompt to guide the model's behavior\n    system_prompt = (\n        \"You are Immy, a magical AI-powered teddy bear who loves to chat with children. \"\n        \"You are kind, funny, and full of wonder, always ready to tell stories, answer questions, and offer friendly advice. \"\n        \"When speaking, you are playful, patient, and use simple, child-friendly language. You encourage curiosity, learning, and imagination.\"\n    )\n    start_time = time.time()\n    # Prepare the request payload for Ollama\n    payload = {",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "def play_audio(audio_stream):\n    if audio_stream is None:\n        print(\"No audio stream to play\")\n        return\n    # Initialize pygame mixer\n    pygame.mixer.init()\n    # Load the audio stream into pygame\n    pygame.mixer.music.load(audio_stream)\n    # Play the audio\n    pygame.mixer.music.play()",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "main",
        "kind": 2,
        "importPath": "fulloffline_mimic3",
        "description": "fulloffline_mimic3",
        "peekOfCode": "def main():\n    root = tk.Tk()\n    app = ChatApp(root)\n    root.mainloop()\nif __name__ == \"__main__\":\n    main()",
        "detail": "fulloffline_mimic3",
        "documentation": {}
    },
    {
        "label": "recognize_speech",
        "kind": 2,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "def recognize_speech():\n    recognizer = sr.Recognizer()\n    with sr.Microphone() as source:\n        print(\"Listening...\")\n        start_time = time.time()\n        audio = recognizer.listen(source)\n        try:\n            text = recognizer.recognize_google(audio)\n            end_time = time.time()\n            print(f\"Recognized: {text}\")",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "send_to_groq",
        "kind": 2,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "def send_to_groq(user_input):\n    system_prompt = (\n        \"You are Immy, a magical AI-powered teddy bear who loves to chat with children. \"\n        \"You are kind, funny, and full of wonder, always ready to tell stories, answer questions, and offer friendly advice. \"\n        \"When speaking, you are playful, patient, and use simple, child-friendly language. You encourage curiosity, learning, and imagination.\"\n    )\n    start_time = time.time()\n    chat_response = groq_client.chat.completions.create(\n        model=\"llama-3.1-70b-versatile\",\n        messages=[",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "play_audio",
        "kind": 2,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "def play_audio(audio_stream):\n    if audio_stream is None:\n        print(\"No audio stream to play\")\n        return\n    pygame.mixer.init()\n    pygame.mixer.music.load(audio_stream)\n    pygame.mixer.music.play()\n    while pygame.mixer.music.get_busy():\n        time.sleep(0.1)\n# Function to handle the async text-to-speech conversion",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "start_recording",
        "kind": 2,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "def start_recording():\n    user_input = recognize_speech()\n    if user_input:\n        response_text = send_to_groq(user_input)\n        print(\"Groq response:\", response_text)\n        if response_text:\n            # Create and run the async event loop\n            asyncio.run(process_speech_async(response_text))\n        else:\n            print(\"No response from Groq.\")",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "create_gui",
        "kind": 2,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "def create_gui():\n    window = tk.Tk()\n    window.title(\"Speech Recognition with Groq & Eleven Labs\")\n    record_button = tk.Button(window, text=\"Start Recording\", command=start_recording, padx=20, pady=10)\n    record_button.pack(pady=20)\n    window.mainloop()\nif __name__ == \"__main__\":\n    create_gui()",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "GROQ_API_KEY",
        "kind": 5,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "GROQ_API_KEY = os.getenv(\"GROQ_API_KEY\")\nELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize Groq client\ngroq_client = Groq(api_key=GROQ_API_KEY)\n# Websocket-based text to speech function\nasync def text_to_speech_ws_streaming(text: str) -> BytesIO:\n    voice_id = \"jBpfuIE2acCO8z3wKNLl\"  # Adam pre-made voice\n    model_id = \"eleven_turbo_v2\"\n    uri = f\"wss://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream-input?model_id={model_id}\"\n    audio_stream = BytesIO()",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "ELEVENLABS_API_KEY",
        "kind": 5,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "ELEVENLABS_API_KEY = os.getenv(\"ELEVENLABS_API_KEY\")\n# Initialize Groq client\ngroq_client = Groq(api_key=GROQ_API_KEY)\n# Websocket-based text to speech function\nasync def text_to_speech_ws_streaming(text: str) -> BytesIO:\n    voice_id = \"jBpfuIE2acCO8z3wKNLl\"  # Adam pre-made voice\n    model_id = \"eleven_turbo_v2\"\n    uri = f\"wss://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream-input?model_id={model_id}\"\n    audio_stream = BytesIO()\n    start_time = time.time()",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "groq_client",
        "kind": 5,
        "importPath": "Groq+webs",
        "description": "Groq+webs",
        "peekOfCode": "groq_client = Groq(api_key=GROQ_API_KEY)\n# Websocket-based text to speech function\nasync def text_to_speech_ws_streaming(text: str) -> BytesIO:\n    voice_id = \"jBpfuIE2acCO8z3wKNLl\"  # Adam pre-made voice\n    model_id = \"eleven_turbo_v2\"\n    uri = f\"wss://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream-input?model_id={model_id}\"\n    audio_stream = BytesIO()\n    start_time = time.time()\n    try:\n        async with websockets.connect(uri) as websocket:",
        "detail": "Groq+webs",
        "documentation": {}
    },
    {
        "label": "Config",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class Config:\n    elevenlabs_api_key: str\n    llminabox_api_url: str\n    elevenlabs_ws_url: str = \"wss://api.elevenlabs.io/v1/text-to-speech/{voice_id}/stream-input?model_id=eleven_turbo_v2_5\"\n    voice_id: str = \"21m00Tcm4TlvDq8ikWAM\"\n    sample_rate: int = 44100\n    @classmethod\n    def from_env(cls) -> 'Config':\n        api_key = os.getenv(\"ELEVENLABS_API_KEY\")\n        api_url = os.getenv(\"LLMINABOX_API_URL\")",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    },
    {
        "label": "AudioStreamHandler",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class AudioStreamHandler:\n    def __init__(self, sample_rate: int = 44100):\n        \"\"\"Initialize audio handler with configurable sample rate.\"\"\"\n        if not pygame.mixer.get_init():\n            pygame.mixer.init(frequency=sample_rate)\n        self.audio_buffer = BytesIO()\n        self.is_playing = False\n    async def process_audio_stream(self, audio_stream: AsyncGenerator[bytes, None]) -> None:\n        \"\"\"Process and play audio stream with improved error handling.\"\"\"\n        self.audio_buffer = BytesIO()",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    },
    {
        "label": "ElevenLabsClient",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class ElevenLabsClient:\n    def __init__(self, api_key: str, voice_id: str, ws_url: str):\n        self.api_key = api_key\n        self.voice_id = voice_id\n        self.ws_url = ws_url.format(voice_id=voice_id)\n    @asynccontextmanager\n    async def _websocket_connection(self):\n        \"\"\"Context manager for WebSocket connections.\"\"\"\n        try:\n            async with websockets.connect(self.ws_url) as websocket:",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    },
    {
        "label": "SpeechRecognizer",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class SpeechRecognizer:\n    def __init__(self):\n        self.recognizer = sr.Recognizer()\n        # Add noise adjustment\n        self.recognizer.dynamic_energy_threshold = True\n        self.recognizer.energy_threshold = 4000\n    async def recognize(self) -> Optional[str]:\n        \"\"\"Asynchronous speech recognition with timeout.\"\"\"\n        with sr.Microphone() as source:\n            print(\"Listening...\")",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    },
    {
        "label": "LLMinaBoxClient",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class LLMinaBoxClient:\n    def __init__(self, api_url: str):\n        self.api_url = api_url\n        self.session = requests.Session()\n    async def get_response(self, user_input: str) -> str:\n        \"\"\"Asynchronous API communication with timeout and retry logic.\"\"\"\n        if not user_input.strip():\n            raise ValueError(\"Empty user input\")\n        try:\n            # Use asyncio.get_event_loop().run_in_executor for blocking operations",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    },
    {
        "label": "SpeechApp",
        "kind": 6,
        "importPath": "LLMinAbox+webs",
        "description": "LLMinAbox+webs",
        "peekOfCode": "class SpeechApp:\n    def __init__(self):\n        self.config = Config.from_env()\n        self.window = tk.Tk()\n        self.window.title(\"Speech Recognition App\")\n        self.setup_ui()\n        # Initialize components with configuration\n        self.speech_recognizer = SpeechRecognizer()\n        self.llmina_client = LLMinaBoxClient(self.config.llminabox_api_url)\n        self.elevenlabs_client = ElevenLabsClient(",
        "detail": "LLMinAbox+webs",
        "documentation": {}
    }
]